From afbfdcff3b3cd14f16736b7c84e04fe9ad61ef8d Mon Sep 17 00:00:00 2001
From: Erik Verbruggen <erik.verbruggen@digia.com>
Date: Wed, 27 Jan 2016 12:08:18 +0100
Subject: [PATCH] QML: do not wrap property values of type QVariant.

When reading a propety from a QGadget or a QObject, the values are
stored in a QVariant and later unwrapped/converted to the correct
JavaScript type. However, if the property value is a QVariant, it does
not need to wrap it (again) in a QVariant.

Change-Id: I633d3194f82b6032fc15d9994c4dee5e5609fd21
Reviewed-by: Simon Hausmann <simon.hausmann@theqtcompany.com>
---
 src/qml/qml/qqmlvaluetypewrapper.cpp                 | 10 ++++++++--
 tests/auto/qml/qqmlvaluetypes/tst_qqmlvaluetypes.cpp | 18 ++++++++++++++++++
 2 files changed, 26 insertions(+), 2 deletions(-)

diff --git a/src/qml/qml/qqmlvaluetypewrapper.cpp b/src/qml/qml/qqmlvaluetypewrapper.cpp
index 8ddf91e..5486c14 100644
--- a/src/qml/qml/qqmlvaluetypewrapper.cpp
+++ b/src/qml/qml/qqmlvaluetypewrapper.cpp
@@ -357,8 +357,14 @@ ReturnedValue QQmlValueTypeWrapper::get(const Managed *m, String *name, bool *ha
     VALUE_TYPE_LOAD(QMetaType::QString, QString, v4->newString);
     VALUE_TYPE_LOAD(QMetaType::Bool, bool, bool);
 
-    QVariant v(result->propType, (void *)0);
-    void *args[] = { v.data(), 0 };
+    QVariant v;
+    void *args[] = { Q_NULLPTR, Q_NULLPTR };
+    if (result->propType == QMetaType::QVariant) {
+        args[0] = &v;
+    } else {
+        v = QVariant(result->propType, static_cast<void *>(Q_NULLPTR));
+        args[0] = v.data();
+    }
     metaObject->d.static_metacall(reinterpret_cast<QObject*>(gadget), QMetaObject::ReadProperty, index, args);
     return v4->fromVariant(v);
 #undef VALUE_TYPE_ACCESSOR
diff --git a/tests/auto/qml/qqmlvaluetypes/tst_qqmlvaluetypes.cpp b/tests/auto/qml/qqmlvaluetypes/tst_qqmlvaluetypes.cpp
index 5875592..04abe0b 100644
--- a/tests/auto/qml/qqmlvaluetypes/tst_qqmlvaluetypes.cpp
+++ b/tests/auto/qml/qqmlvaluetypes/tst_qqmlvaluetypes.cpp
@@ -1493,6 +1493,7 @@ struct MyOffice
 {
     Q_PROPERTY(int chairs MEMBER m_chairs)
     Q_PROPERTY(MyDesk desk READ desk WRITE setDesk)
+    Q_PROPERTY(QVariant myThing READ myThing WRITE setMyThing)
     Q_GADGET
 public:
     MyOffice() : m_chairs(0) {}
@@ -1500,8 +1501,12 @@ public:
     MyDesk desk() const { return m_desk; }
     void setDesk(const MyDesk &d) { m_desk = d; }
 
+    QVariant myThing() const { return m_myThing; }
+    void setMyThing(const QVariant &thingy) { m_myThing = thingy; }
+
     int m_chairs;
     MyDesk m_desk;
+    QVariant m_myThing;
 };
 
 Q_DECLARE_METATYPE(MyOffice)
@@ -1513,6 +1518,11 @@ void tst_qqmlvaluetypes::customValueType()
     MyOffice cppOffice;
     cppOffice.m_chairs = 2;
 
+    QVariantMap m;
+    m.insert(QStringLiteral("hasChair"), false);
+    m.insert(QStringLiteral("textOnWhiteboard"), QStringLiteral("Blah blah"));
+    cppOffice.m_myThing = m;
+
     QJSValue office = engine.toScriptValue(cppOffice);
     QCOMPARE(office.property("chairs").toInt(), 2);
     office.setProperty("chairs", 1);
@@ -1530,6 +1540,14 @@ void tst_qqmlvaluetypes::customValueType()
     cppOffice = engine.fromScriptValue<MyOffice>(office);
     QCOMPARE(cppOffice.m_chairs, 1);
     QCOMPARE(cppOffice.desk().monitorCount, 2);
+
+    QJSValue thingy = office.property("myThing");
+    QVERIFY(thingy.hasProperty("hasChair"));
+    QVERIFY(thingy.property("hasChair").isBool());
+    QCOMPARE(thingy.property("hasChair").toBool(), false);
+    QVERIFY(thingy.property("textOnWhiteboard").isString());
+    QVERIFY(thingy.hasProperty("textOnWhiteboard"));
+    QCOMPARE(thingy.property("textOnWhiteboard").toString(), QStringLiteral("Blah blah"));
 }
 
 struct BaseGadget
-- 
2.7.4

